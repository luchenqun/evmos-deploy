## background
In the development mode, if you want to verify P2P, consensus algorithm and other modules, generally you need to run 4 nodes. Officially, EVMOS offers two ways, [Multi Node](https://docs.evmos.org/developers/localnet/multi_node.html) and [Testnet Command](https://docs.evmos.org/developers/localnet/testnet_cmd.html), to run multi-node. However, these two methods have the following disadvantages:
* Multi Node is actually built with docker, which is not very friendly to development.
* Whilst, the Testnet Command way leads to that many ports share the same port number after creating the configuration of 4 nodes, which makes it unable to start up local nodes properly. Moreover, this mode starts all nodes within one process, which makes it impossible to simulate a multi-node development env.

Based on the requirements and current situation mentioned above, we manage to work out a solution on top of Testnet Command mode. By using JavaScript script to implement a command, we can start up multiple nodes and set up multi-node environment in a few seconds.

## How to use it
* Install 16.x node.js.
* Execute `npm i` installation dependencies in the project directory.
* Put your compiled **evmosd** executable program in the project directory, or go to https://github.com/evmos/evmos/releases to download the version you need .
* Copy the content of config.default.json to a newly created file named config.json. Update the configuration according to your requirements.
* Execute `node init.js --start true` or `node init.js --s true`。In addition to the start parameter, other parameters are as follows：
  * nohup(alias n): type is bool, startup script is started in the background with nohup, which is true by default
  * platform(alias p): type is string, the current platform (Darwin, Linux, and Win32), which is empty by default and is not transferred to be obtained through process.platform
  * start(alias s): type is bool, whether to start all nodes immediately after initialization. The default value is false
  * validators(alias v): type is number, the number of consensus nodes of validators. The default value is 4
  * commonNode(alias cn): type is number, the number of common nodes. The default value is 0
  * compile(alias c): type is bool, recompile of evmos code to generate evmosd excutable program. Note: this pattern requires the project to be placed in the evmos project code directory.
* Execute `npm run start` (It's actually node start.js) to start all nodes.
* Execute `npm run stop` (It's actually node stop.js) to stop all nodes.

## Some tips
* If the evmosd executable does not exist under the directory, it actively attempts to compile.
* Generate the script file under the nodes directory, you can make changes or start the part as you needed.
* Because the ports of the configuration files generated by using the command `evmosd testnet init-files` are the same, it is obvious that multi nodes cannot be started on the same machine. So I will automatically update the port of the profile. For example, if the RPC server port is 26657, then the first node is 26657, and the second is 26658. All nodes are incremented in turn. However, because some ports are adjacent, for example, grpcport is 9090, and grpcwebport is 9091. If both are incremented, there is still a conflict. At this time, I will increase a certain port and decrease a certain port. Port increments or decrements are as follows:
  * swaggerPort: +incremental
  * rosettaPort: +incremental
  * grpcPort: -decremental
  * grpcWebPort: +incremental
  * jsonRpcPort: -decremental
  * wsRpcPort: +incremental
  * rpcServerPort: +incremental
  * p2pPort: +incremental
  * pprofPort: +incremental
* If you want to compile code during initialization, it is best to put the project into the evmos project code directory and rename it to the **build** directory. The git of the evmos project has ignored the change of the build directory.
* It can be integrated with another development tool [cosmos tool](http://cosmos.lucq.fun/)(only dashboard and RPC modules have been completed at present) to view chain information.

## 背景
在开发的过程中，验证p2p，共识算法等模块一般需要搭建4节点。官方提供了[Multi Node](https://docs.evmos.org/developers/localnet/multi_node.html)以及[Testnet command](https://docs.evmos.org/developers/localnet/testnet_cmd.html)这两种方式搭建多节点的方式。但是这两种方式有如下缺点：Multi Node 实际是使用docker搭建的，对开发不太友好。而 Testnet command 的方式创建好4节点的配置之后，很多的端口是使用的是同一个端口导致无法启动。而且该方式是在同一个进程里面启动得，无法模拟开发模式。

基于上面的需求以及现状，在官方提供的 Testnet command 模式的基础上，使用JavaScript脚本实现一个命令就能启动多节点。能够在几秒的时间内搭建一个多节点的运行环境。

## 使用步骤
* 安装Node.js，安装v16.x版本。
* 在项目目录执行npm i安装依赖。
* 将你编译好的evmosd放到项目目录，或者到 https://github.com/evmos/evmos/releases 进行下载你需要的版本。
* config.default.json为蓝本，将内容复制一份到新建的文件config.json里面。按照你的需求你更新一下配置。
* 执行 `node init.js --start true`  或者 `node init.js --s true`。除了 start 参数，其他参数如下：
  * nohup(简写为n) 启动脚本是在后台用 nohup 启动，默认 true
  * platform(简写为p) 当前平台(darwin,linux,win32)，默认空，不传通过process.platform获取
  * start(简写为s) 初始化之后是否立即启动所有节点，默认 false
  * validators(简写为v) 共识节点的个数，默认为 4 个
  * commonNode(简写为cn) 普节点的个数，默认为 0 个
  * compile(简写为c) 是否需要强制重新编译代码。注意：此模式需要该项目放到evmos项目代码目录。
* 执行 npm run start 启动所有节点。
* 执行 npm run stop 停止所有节点。

## 一些小提示
* 如果目录下面不存在evmosd可执行文件，会主动尝试进行编译。
* 生成的nodes目录下面的脚本文件，你可以根据需要进行改动或者启动部分。
* 因为使用命令 evmosd testnet init-files 生成的配置文件的端口都是同样的，在同一台机器显然这样是无法启动多节点的。所以我会自动更新配置文件的端口。比如rpc Server Port 为 26657，那么第一个节点为 26657，第二个为 26658，所有节点依次递增。但是由于有些端口是相邻的，比如 grpcPort 为 9090，而 grpcWebPort 为 9091，如果都递增显然还是有冲突，此时我会某个端口递增，某个端口递减。端口递增还是递减如下所示：
  * swaggerPort +递增
  * rosettaPort +递增
  * grpcPort -递减
  * grpcWebPort +递增
  * jsonRpcPort -递减
  * wsRpcPort +递增
  * rpcServerPort +递增
  * p2pPort +递增
  * pprofPort +递增
* 如果需要在初始化执行编译代码，最好是将项目放到evmos项目代码目录之后重命名为build目录，evmos项目的Git已经忽略了build目录的改动。
* 可以配合另外一个开发工具[cosmos-tool](http://cosmos.lucq.fun/) (目前只完成了dashboard与rpc两个模块)查看链信息。

## 问题
* 在同一台机器下面运行多个节点，一定要将config.toml配置中的allow_duplicate_ip = false改为allow_duplicate_ip = true，否则多节点p2p无法连起来。详细可见:[Issue with peer connectivity](https://github.com/tendermint/tendermint/issues/6156)。我将那段话复制过来：
  ```
  I've fixed this.
  
  Since all the p2p traffic was being routed through the nginx proxy server,
  the ips in the peer connection were the same.
  The proxy server was just using different sockets to connect to the tendermint node.
  So, the new peers were being rejected.
  
  I fixed it by enabling AllowDuplicateIP in tm p2p config.
  
  Thank you for your time!
  ```